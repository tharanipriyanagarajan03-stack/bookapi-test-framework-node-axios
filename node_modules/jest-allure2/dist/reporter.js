"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.WrappedStep = exports.JasmineAllureInterface = exports.JasmineAllureReporter = void 0;
const allure_js_commons_1 = require("allure-js-commons");
const path_1 = __importDefault(require("path"));
const strip_ansi_1 = __importDefault(require("strip-ansi"));
var SpecStatus;
(function (SpecStatus) {
    SpecStatus["PASSED"] = "passed";
    SpecStatus["FAILED"] = "failed";
    SpecStatus["BROKEN"] = "broken";
    SpecStatus["PENDING"] = "pending";
    SpecStatus["DISABLED"] = "disabled";
    SpecStatus["EXCLUDED"] = "excluded";
    SpecStatus["TODO"] = "todo";
})(SpecStatus || (SpecStatus = {}));
class JasmineAllureReporter {
    constructor(config) {
        this.runningExecutable = null;
        this.groupStack = [];
        this.labelStack = [[]];
        this.runningTest = null;
        this.stepStack = [];
        this.config = config;
        this.runtime = new allure_js_commons_1.AllureRuntime(config);
        this.installHooks();
    }
    get isSuite() {
        return false;
    }
    getInterface() {
        return new JasmineAllureInterface(this, this.runtime);
    }
    get currentGroup() {
        const currentGroup = this.getCurrentGroup();
        if (currentGroup === null) {
            throw new Error('No active group');
        }
        return currentGroup;
    }
    get currentTest() {
        if (this.runningTest === null) {
            throw new Error('No active test');
        }
        return this.runningTest;
    }
    get currentExecutable() {
        return this.runningExecutable;
    }
    writeAttachment(content, type) {
        return this.runtime.writeAttachment(content, type);
    }
    jasmineStarted(_suiteInfo) {
        // Console.log(`Jest Worker #${process.env.JEST_WORKER_ID} has started.`)
    }
    // SuiteStarted(suite: jasmine.CustomReporterResult): void {
    // 	// SuiteStarted is only triggered when a test is nested in a describe block
    // 	this.isSuite = true
    // 	// Group all specs of describe block together using wrapper.
    // 	const name = suite.description
    // 	const group = (this.getCurrentGroup() ?? this.runtime).startGroup(name)
    // 	this.groupStack.push(group)
    // 	this.labelStack.push([])
    // }
    specStarted(spec) {
        var _a;
        let specPathArray = [];
        // Special behavior if test is not using describe blocks
        if (!this.isSuite) {
            const { projectDir } = this.config;
            const { testPath } = spec;
            specPathArray = projectDir ?
                path_1.default.relative(projectDir, testPath).split('/') :
                testPath.split('/');
            if (specPathArray.length > 0) {
                const group = ((_a = this.getCurrentGroup()) !== null && _a !== void 0 ? _a : this.runtime).startGroup(specPathArray[0]);
                this.groupStack.push(group);
                this.labelStack.push([]);
            }
        }
        // Checking current context
        let currentGroup = this.getCurrentGroup();
        if (currentGroup === null) {
            throw new Error('No active suite');
        }
        // Wrapper to hold beforeEach/afterEach
        currentGroup = currentGroup.startGroup('Test wrapper');
        this.groupStack.push(currentGroup);
        // Starting test
        const specName = spec.description;
        const allureTest = currentGroup.startTest(specName);
        // Check context for invalid state
        if (this.runningTest !== null) {
            throw new Error('Test is starting before other ended!');
        }
        // Set context state
        this.runningTest = allureTest;
        allureTest.fullName = spec.fullName;
        allureTest.historyId = spec.fullName;
        allureTest.stage = allure_js_commons_1.Stage.RUNNING;
        // If describe blocks are being used, then use describe block names for report organization.
        if (this.isSuite) {
            if (this.groupStack.length > 1) {
                allureTest.addLabel(allure_js_commons_1.LabelName.PARENT_SUITE, this.groupStack[0].name);
            }
            if (this.groupStack.length > 2) {
                allureTest.addLabel(allure_js_commons_1.LabelName.SUITE, this.groupStack[1].name);
            }
            if (this.groupStack.length > 3) {
                allureTest.addLabel(allure_js_commons_1.LabelName.SUB_SUITE, this.groupStack[2].name);
            }
        }
        // If test is not using describe blocks, then use file path for report organization.
        // Note: ignore the beforeEach/afterEach wrapper, index + 1
        if (!this.isSuite && specPathArray.length > 1) {
            // Lowest level is the test file name (ie: functionality.test.js)
            allureTest.addLabel(allure_js_commons_1.LabelName.SUB_SUITE, specPathArray[specPathArray.length - 1]);
            // Next level is the test file's dir name (ie: POST/GET/PUT/DELETE)
            allureTest.addLabel(allure_js_commons_1.LabelName.SUITE, specPathArray[specPathArray.length - 2]);
            // Top level is the rest of the file path (ie: user/info)
            allureTest.addLabel(allure_js_commons_1.LabelName.PARENT_SUITE, specPathArray.slice(0, -2).join('/'));
            // Packages tab should be organized by root folder of file path. (ie: user)
            allureTest.addLabel(allure_js_commons_1.LabelName.PACKAGE, specPathArray[0]);
        }
        // Capture Jest worker thread for timeline report
        if (process.env.JEST_WORKER_ID) {
            this.addLabel(allure_js_commons_1.LabelName.THREAD, `${process.env.JEST_WORKER_ID}`);
        }
        // Recursively add labels to the test instance
        for (const labels of this.labelStack) {
            for (const label of labels) {
                allureTest.addLabel(label.name, label.value);
            }
        }
    }
    specDone(spec) {
        var _a, _b, _c, _d, _e;
        if (this.runningTest === null) {
            throw new Error('specDone while no test is running');
        }
        const currentTest = this.runningTest;
        // Console.log('specDone currentTest:', JSON.stringify(currentTest, null, 2))
        // If steps were not finished before the spec finished, then notify and clear stepStack.
        if (this.stepStack.length > 0) {
            // Console.error('this.stepStack:', this.stepStack)
            console.error('this.stepStack:', JSON.stringify(this.stepStack, null, 2));
            console.error('Allure reporter issue: step stack is not empty on specDone');
            for (const step of this.stepStack.reverse()) {
                step.status = allure_js_commons_1.Status.BROKEN;
                step.stage = allure_js_commons_1.Stage.INTERRUPTED;
                step.detailsMessage =
                    'Test ended unexpectedly before step could complete.';
                step.endStep();
            }
            this.stepStack = [];
        }
        // Capture test result/status
        if (spec.status === SpecStatus.PASSED) {
            currentTest.status = allure_js_commons_1.Status.PASSED;
            currentTest.stage = allure_js_commons_1.Stage.FINISHED;
        }
        if (spec.status === SpecStatus.BROKEN) {
            currentTest.status = allure_js_commons_1.Status.BROKEN;
            currentTest.stage = allure_js_commons_1.Stage.FINISHED;
        }
        if (spec.status === SpecStatus.FAILED) {
            currentTest.status = allure_js_commons_1.Status.FAILED;
            currentTest.stage = allure_js_commons_1.Stage.FINISHED;
        }
        if ((_c = (_b = (_a = spec.status === SpecStatus.PENDING) !== null && _a !== void 0 ? _a : spec.status === SpecStatus.DISABLED) !== null && _b !== void 0 ? _b : spec.status === SpecStatus.EXCLUDED) !== null && _c !== void 0 ? _c : spec.status === SpecStatus.TODO) {
            currentTest.status = allure_js_commons_1.Status.SKIPPED;
            currentTest.stage = allure_js_commons_1.Stage.PENDING;
            currentTest.detailsMessage = (_d = spec.pendingReason) !== null && _d !== void 0 ? _d : 'Suite disabled';
        }
        // Capture exceptions
        const exceptionInfo = (_e = this.findMessageAboutThrow(spec.failedExpectations)) !== null && _e !== void 0 ? _e : this.findAnyError(spec.failedExpectations);
        if (exceptionInfo !== null && typeof exceptionInfo.message === 'string') {
            let { message } = exceptionInfo;
            message = strip_ansi_1.default(message);
            currentTest.detailsMessage = strip_ansi_1.default(message);
            if (exceptionInfo.stack && typeof exceptionInfo.stack === 'string') {
                let { stack } = exceptionInfo;
                stack = strip_ansi_1.default(stack);
                stack = stack.replace(message, '');
                currentTest.detailsTrace = stack;
            }
        }
        // Finished with test
        currentTest.endTest();
        this.runningTest = null;
        // Popping test wrapper
        this.currentGroup.endGroup();
        this.groupStack.pop();
        // If test was not in a describe block, end the group wrapper
        if (!this.isSuite) {
            const currentGroup = this.getCurrentGroup();
            if (currentGroup === null) {
                throw new Error('No active suite');
            }
            currentGroup.endGroup();
            this.groupStack.pop();
            this.labelStack.pop();
        }
    }
    // SuiteDone(_suite: jasmine.CustomReporterResult): void {
    // 	if (!this.isSuite) console.error('Allure reporter issue: suiteDone called without suiteStart context.')
    // 	if (this.runningTest !== null) console.error('Allure reporter issue: A test was running on suiteDone.')
    // 	const currentGroup = this.getCurrentGroup()
    // 	if (currentGroup === null) throw new Error('No active suite.')
    // 	currentGroup.endGroup()
    // 	this.groupStack.pop()
    // 	this.labelStack.pop()
    // }
    jasmineDone(_runDetails) {
        // Console.log(`Jest Worker #${process.env.JEST_WORKER_ID} has finished.`)
    }
    addLabel(name, value) {
        if (this.labelStack.length > 0) {
            this.labelStack[this.labelStack.length - 1].push({ name, value });
        }
    }
    pushStep(step) {
        this.stepStack.push(step);
    }
    popStep() {
        this.stepStack.pop();
    }
    get currentStep() {
        if (this.stepStack.length > 0) {
            return this.stepStack[this.stepStack.length - 1];
        }
        return null;
    }
    getCurrentGroup() {
        if (this.groupStack.length === 0) {
            return null;
        }
        return this.groupStack[this.groupStack.length - 1];
    }
    findMessageAboutThrow(expectations) {
        for (const expectation of expectations !== null && expectations !== void 0 ? expectations : []) {
            if (expectation.matcherName === '') {
                return expectation;
            }
        }
        return null;
    }
    findAnyError(expectations) {
        expectations = expectations !== null && expectations !== void 0 ? expectations : [];
        if (expectations.length > 0) {
            return expectations[0];
        }
        return null;
    }
    // TODO: Add support for manually adding setup execution steps.
    installHooks() {
        // Const reporter = this
        const jasmineBeforeAll = eval('global.beforeAll');
        const jasmineAfterAll = eval('global.afterAll');
        const jasmineBeforeEach = eval('global.beforeEach');
        const jasmineAfterEach = eval('global.afterEach');
        function makeWrapperAll(wrapped, fun) {
            return function (action, timeout) {
                wrapped(function (done) {
                    this.runningExecutable = fun();
                    let returnValue;
                    if (action.length > 0) {
                        // Function takes done callback
                        returnValue = this.runningExecutable.wrap(async () => new Promise((resolve, reject) => {
                            const t = resolve;
                            t.fail = reject;
                            action(t);
                        }))();
                    }
                    else {
                        returnValue = this.runningExecutable.wrap(action)();
                    }
                    if (allure_js_commons_1.isPromise(returnValue)) {
                        returnValue
                            .then(() => {
                            this.runningExecutable = null;
                            done();
                        })
                            .catch(error => {
                            this.runningExecutable = null;
                            done.fail(error);
                        });
                    }
                    else {
                        this.runningExecutable = null;
                        done();
                    }
                }, timeout);
            };
        }
        const wrapperBeforeAll = makeWrapperAll(jasmineBeforeAll, () => this.currentGroup.addBefore());
        const wrapperAfterAll = makeWrapperAll(jasmineAfterAll, () => this.currentGroup.addAfter());
        const wrapperBeforeEach = makeWrapperAll(jasmineBeforeEach, () => this.currentGroup.addBefore());
        const wrapperAfterEach = makeWrapperAll(jasmineAfterEach, () => this.currentGroup.addAfter());
        eval('global.beforeAll = wrapperBeforeAll;');
        eval('global.afterAll = wrapperAfterAll;');
        eval('global.beforeEach = wrapperBeforeEach;');
        eval('global.afterEach = wrapperAfterEach;');
    }
}
exports.JasmineAllureReporter = JasmineAllureReporter;
// TODO: Move this to it's own file
class JasmineAllureInterface extends allure_js_commons_1.Allure {
    constructor(reporter, runtime) {
        super(runtime);
        this.reporter = reporter;
    }
    setup(body) {
        this.reporter.runningExecutable = this.reporter.currentGroup.addBefore();
        const result = this.reporter.runningExecutable.wrap(body)();
        if (allure_js_commons_1.isPromise(result)) {
            const promise = result;
            return promise
                .then(a => {
                this.reporter.runningExecutable = null;
                return a;
            })
                .catch(error => {
                this.reporter.runningExecutable = null;
                throw error;
            });
        }
        if (!allure_js_commons_1.isPromise(result)) {
            this.reporter.runningExecutable = null;
            return result;
        }
    }
    step(name, body) {
        const wrappedStep = this.startStep(name);
        let result;
        try {
            result = wrappedStep.run(body);
        }
        catch (error) {
            wrappedStep.endStep();
            throw error;
        }
        if (allure_js_commons_1.isPromise(result)) {
            const promise = result;
            return promise
                .then(a => {
                wrappedStep.endStep();
                return a;
            })
                .catch(error => {
                wrappedStep.endStep();
                throw error;
            });
        }
        if (!allure_js_commons_1.isPromise(result)) {
            wrappedStep.endStep();
            return result;
        }
    }
    logStep(name, status, attachments) {
        console.log('JasmineAllureInterface status:', status);
        const wrappedStep = this.startStep(name);
        if (attachments) {
            for (const { name, content, type } of attachments) {
                this.attachment(name, content, type);
            }
        }
        wrappedStep.logStep(status);
        wrappedStep.endStep();
    }
    attachment(name, content, type) {
        const file = this.reporter.writeAttachment(content, type);
        this.currentExecutable.addAttachment(name, type, file);
    }
    parameter(name, value) {
        this.label(name, value);
    }
    label(name, value) {
        try {
            this.reporter.currentTest.addLabel(name, value);
        }
        catch {
            this.reporter.addLabel(name, value);
        }
    }
    startStep(name) {
        const allureStep = this.currentExecutable.startStep(name);
        this.reporter.pushStep(allureStep);
        return new WrappedStep(this.reporter, allureStep);
    }
    get currentExecutable() {
        var _a, _b;
        return ((_b = (_a = this.reporter.currentStep) !== null && _a !== void 0 ? _a : this.reporter.currentExecutable) !== null && _b !== void 0 ? _b : this.reporter.currentTest);
    }
    get currentTest() {
        return this.reporter.currentTest;
    }
}
exports.JasmineAllureInterface = JasmineAllureInterface;
// TODO: Move this to it's own file
class WrappedStep {
    constructor(reporter, step) {
        this.reporter = reporter;
        this.step = step;
    }
    startStep(name) {
        const step = this.step.startStep(name);
        this.reporter.pushStep(step);
        return new WrappedStep(this.reporter, step);
    }
    attach(name, content, type) {
        const file = this.reporter.writeAttachment(content, type);
        this.step.addAttachment(name, type, file);
    }
    param(name, value) {
        this.step.addParameter(name, value);
    }
    logStep(status) {
        console.log('WrappedStep status:', status);
        this.step.status = status;
    }
    run(body) {
        return this.step.wrap(body)();
    }
    endStep() {
        this.reporter.popStep();
        this.step.endStep();
    }
}
exports.WrappedStep = WrappedStep;
//# sourceMappingURL=reporter.js.map